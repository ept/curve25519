\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=2.5cm]{geometry}
\usepackage[english]{babel}
\usepackage[hidelinks]{hyperref}
\usepackage{url}
\usepackage{doi}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools} % dcases environment
\usepackage{tikz}

% The minted package does source code syntax highlighting using Pygments: https://pygments.org/
% Pygments must be installed on your system, e.g. using `pip3.8 install Pygments`.
% pdflatex must be run with option -shell-escape so that it can run pygmentize.
% To allow the document to be built on systems without Pygments, commit the files in the
% _minted-curve25519/ directory to git. Use option finalizecache=true to update the cached
% syntax-highlighted listings, and use option frozencache=true to use that cache.
% With frozencache=true, the -shell-escape option is no longer needed.
\usepackage[finalizecache=true]{minted}

\urlstyle{rm}

\begin{document}
\def\listingautorefname{Listing}%
\def\sectionautorefname{Section}%
\def\subsectionautorefname{Section}%
\def\subsubsectionautorefname{Section}%

\title{Deriving an implementation of Curve25519 from first principles}
\author{Martin Kleppmann}
\date{}
\maketitle
\begin{abstract}
TODO
\end{abstract}

\section{Introduction}

Many textbooks cover the concepts behind Elliptic Curve Cryptography~\cite{Cohen:2006,Hankerson:2004}, but few discuss the details of how you go from the equations to an actual working and secure implementation of the algorithms.
They also tend to leave out the tedious algebraic derivations, making it difficult to convince ourselves that the results they present are really correct.
On the other hand, cryptographic libraries don't tend to have much documentation explaining how their code came about and why it is correct.

The goal of this document is to bridge the gap between the mathematics and the code for one particular elliptic curve algorithm, the Curve25519 function for Diffie-Hellman key agreement~\cite{Bernstein:2006kw}.
Curve25519 is the basis of the X25519 standard~\cite{X25519}, which is a mandatory algorithm in TLS 1.3~\cite{TLS13}, and is also used in WhatsApp~\cite{WhatsAppWhitepaper}, Signal~\cite{Marlinspike:2016}, and various other systems and protocols.

We will examine the implementation of Curve25519 in TweetNaCl~\cite{Bernstein:2014ca,TweetNaCl}, a small but practical cryptography library with the same API as NaCl~\cite{NaCl,Bernstein:2012}.
(The name derives from the fact that the implementation fits in 100 tweets of up to 140 characters each.)
TweetNaCl is originally in C, but its simplicity has made it popular for porting to various other languages, such as JavaScript~\cite{TweetNaCljs}.
Despite its simplicity, TweetNaCl has strong security properties that we expect of fully-fledged cryptography libraries: in particular, it uses constant-time algorithms to prevent side-channel attacks (that is, it performs no branches or array lookups based on secret values), and it is secure against all known attacks.

TweetNaCl advertises itself as ``auditable''~\cite{Bernstein:2014ca} in the sense that its code is short and simple enough that its correctness can be established through code review.
However, to our knowledge, no detail of any such audit has been published.
The JavaScript port has indeed been professionally audited, but the report~\cite{TweetNaClAudit} does not go into any technical detail.
Previous analyses of NaCl/TweetNaCl~\cite{Bernstein:2009,Janssen:2014} give justification for some of the algorithms, but also leave many details unexplained.

Therefore, in this document, we will re-derive the TweetNaCl implementation of Curve25519 from first principles, including all of the tedious algebra.
(We will not discuss the other algorithms that appear in TweetNaCl, such as the Salsa20 stream cipher, the Poly1305 authenticator, or the Ed25519 signature scheme.)
The goal is to fully explain and justify every line of code that appears in the implementation.
This document assumes only a basic background in discrete mathematics (such as modular arithmetic), and requires no prior knowledge on elliptic curves.

Unlike HACL*~\cite{HACLStar}, which contains a formally verified implementation of Curve25519~\cite{Zinzindohoue:2017fc}, the goal of this document is not so much to verify that TweetNaCl is correct, but rather to learn how Elliptic Curve Cryptography works by carefully studying one particular algorithm and its implementation.

\section{Elliptic Curve Arithmetic}\label{sec:curve-arithmetic}

Curve25519 uses the curve
\begin{equation}\label{eq:curve}
y^2 = x^3 + A x^2 + x
\end{equation}
which is known as a \emph{Montgomery curve}, with parameter $A = 486662$.
We will use equation~\eqref{eq:curve} as our starting point; a justification for the use of this equation and the choice of $A$ appear in the Curve25519 paper \cite{Bernstein:2006kw}.
Our derivations work for any $A^2 \ne 4$; this restriction ensures the curve has the required shape.
% TODO can we use Sage to compute the number of points on the curve?

\begin{figure}
% Points for first plot are computed as follows:
% a = -1.9
% xp = 0.1; yp = -sqrt(xp*xp*xp + a*xp*xp + xp)
% xq = 0.8; yq =  sqrt(xq*xq*xq + a*xq*xq + xq)
% m = (yq - yp) / (xq - xp)
% xa = -0.1; ya = yp - m * (xp - xa)
% xb =  2.0; yb = ya + m * (xb - xa)
% xc = m*m - a - xp - xq; yc = yp + m * (xc - xp)
\begin{tikzpicture}[scale=3.0]
\node at (0.2,-1.5) {(a)};
\draw [->] (-0.1,0) -- (2.1,0) node[right] {$x$};
\draw [->] (0,-1.6) -- (0,1.6) node[above] {$y$};
\draw [color=blue] plot[id=pos,domain=0:2,samples=100] function{ sqrt(x**3 - 1.9*x**2 + x)};
\draw [color=blue] plot[id=neg,domain=0:2,samples=100] function{-sqrt(x**3 - 1.9*x**2 + x)};
\draw [color=red] (0.1,-0.28636) circle [radius=1pt] node[below,outer sep=5pt] {$P$};
\draw [color=red] (0.8, 0.30984) circle [radius=1pt] node[above,outer sep=5pt] {$Q$};
\draw [color=red] (1.7254, 1.0980) circle [radius=1pt] node[below,outer sep=5pt] {$R$};
\draw [color=red] (-0.1,-0.45669) -- (2.0,1.331887391631657);
\end{tikzpicture}
\hfill
% Points for the second plot are computed as follows:
% a = -1.9
% xp = 0.3; yp = sqrt(xp*xp*xp + a*xp*xp + xp)
% m = (3*xp*xp + 2*a*xp + 1) / (2*yp)
% xa = -0.1; ya = yp - m * (xp - xa)
% xb =  2.0; yb = ya + m * (xb - xa)
% xc = m*m - a - 2*xp; yc = yp + m * (xc - xp)
\begin{tikzpicture}[scale=3.0]
\node at (0.2,-1.5) {(b)};
\draw [->] (-0.1,0) -- (2.1,0) node[right] {$x$};
\draw [->] (0,-1.6) -- (0,1.6) node[above] {$y$};
\draw [color=blue] plot[id=pos,domain=0:2,samples=100] function{ sqrt(x**3 - 1.9*x**2 + x)};
\draw [color=blue] plot[id=neg,domain=0:2,samples=100] function{-sqrt(x**3 - 1.9*x**2 + x)};
\draw [color=red] (0.25,0.38324) circle [radius=1pt] node [above,outer sep=5pt] {$P=Q$};
\draw [color=red] (1.49601,0.76932) circle [radius=1pt] node [below,outer sep=5pt] {$R$};
\draw [color=red] (-0.1,0.27479) -- (2.0,0.92549);
\end{tikzpicture}
\caption{(a) If we draw a line through two points $P=(x_P,y_P)$ and $Q=(x_Q,y_Q)$ on an elliptic curve, where $x_P \neq x_Q$, then that line intersects the curve again in a third point $R$. (b) Generalising to $P=Q$, we draw a tangent to the curve at $P$, which intersects the curve at $R$.}
\label{fig:curve}
\end{figure}

\subsection{Straight line intersecting the elliptic curve}\label{sec:straight-line}

We say that a point $P = (x_P, y_P)$ lies on the curve if $(x_P, y_P)$ is a solution of equation~\eqref{eq:curve}.
\autoref{fig:curve} shows an example of such a curve.
Notice that the curve has reflection symmetry around the $x$ axis; more formally, if $(x_P, y_P)$ is on the curve then $(x_P, -y_P)$ is also on the curve.
This is the case because the variable $y$ appears only in the $y^2$ term in~\eqref{eq:curve}.

For now we will treat $x$ and $y$ as real numbers.
In cryptography, $x$ and $y$ are in fact integers modulo a large prime, but we will do the following derivation using real numbers as it is easier to visualise.
It turns out that the end result works with both types of numbers.

If we have two points $P=(x_P,y_P)$ and $Q=(x_Q,y_Q)$ that both lie on the curve, we can draw a straight line through those points.
If we assume that $x_P \neq x_Q$, then that straight line intersects the curve at some third point $R$, as shown in \autoref{fig:curve}(a).
We will show shortly that this third point $R$ always exists.
This straight line is defined by the equation
\begin{equation}
y = \lambda x + c \quad\text{ where the slope is }\quad
\lambda = \frac{y_Q - y_P}{x_Q - x_P} \quad\text{ and the $y$-intercept is }\quad c = y_P - \lambda\,x_P. \label{eq:line}
\end{equation}

If $x_P=x_Q$ there are two possibilities: either $y_P=y_Q$, in which case $P=Q$, or $y_P=-y_Q$.
Consider first the case where $P=Q$.
In this case we can still define a straight line through $P$ and $Q$, and we choose the slope of the line such that it is a tangent to the curve (i.e.\ it touches the curve at $P$ without crossing it).
This is the natural generalisation of the slope $(y_Q - y_P)/(x_Q - x_P)$ in the limit as the distance between $P$ and $Q$ tends to zero.

To compute the slope $\lambda$ of this tangent, we can calculate the derivative of the curve equation~\eqref{eq:curve} using the chain rule:
\begin{align}
y^2 &= x^3 + A x^2 + x \quad\iff\quad y = \pm\sqrt{x^3 + A x^2 + x}\\[5pt]
\lambda = \frac{\mathrm{d}y}{\mathrm{d}x} &= \pm\frac{3x^2 + 2Ax + 1}{2\sqrt{x^3 + Ax^2 + x}}
= \pm\frac{3x^2 + 2Ax + 1}{2|y|}
= \frac{3x^2 + 2Ax + 1}{2y} \label{eq:derivative}
\end{align}
The sign of $\lambda$ in equation~\eqref{eq:derivative} works out correctly for both positive and negative $y$.
The tangent is then defined by $y = \lambda x + c$ as before, and it exists whenever $y \ne 0$.
In the case where $y=0$ the tangent would be vertical, and we exclude this case for now.

\begin{figure}
\centering
% a = -1.9; xp = 0.6; yp = -sqrt(xp*xp*xp + a*xp*xp + xp)
\begin{tikzpicture}[scale=3.0]
\draw [->] (-0.1,0) -- (2.1,0) node[right] {$x$};
\draw [->] (0,-1.6) -- (0,1.6) node[above] {$y$};
\draw [color=blue] plot[id=pos,domain=0:2,samples=100] function{ sqrt(x**3 - 1.9*x**2 + x)};
\draw [color=blue] plot[id=neg,domain=0:2,samples=100] function{-sqrt(x**3 - 1.9*x**2 + x)};
\draw [color=red] (0.6,-0.36332) circle [radius=1pt] node[below right,outer sep=5pt] {$P$};
\draw [color=red] (0.6, 0.36332) circle [radius=1pt] node[above right,outer sep=5pt] {$Q$};
\draw [color=red] (0.6,-1.6) -- (0.6,1.6);
\end{tikzpicture}
\caption{If $x_P=x_Q$ and $y_P=-y_Q$, the line going through the two points is vertical.}
\label{fig:vertical}
\end{figure}

Finally, we have the case when $x_P=x_Q$ and $y_P=-y_Q$.
This case is shown in \autoref{fig:vertical}: the straight line going through the two points is vertical.
We will return to this case later.

In the cases where the straight line is not vertical, we work out the third point $R$ at which the line intersects the elliptic curve.
We do this by substituting the line equation~\eqref{eq:line} into the curve equation~\eqref{eq:curve}:
\begin{equation}
(\lambda x + c)^2 = x^3 + Ax^2 + x \quad\iff\quad x^3 + (A - \lambda^2)\, x^2 + (1 - 2\lambda c)\, x - c^2 = 0 \label{eq:intersect}
\end{equation}
The roots of the polynomial~\eqref{eq:intersect} are the $x$ coordinates of the points at which the line intersects the curve.
Since we know that $P$ and $Q$ lie on both the line and the curve, $x_P$ and $x_Q$ must be roots of~\eqref{eq:intersect}, and so we can divide~\eqref{eq:intersect} by the polynomial $(x - x_P)(x - x_Q) = x^2 - (x_P + x_Q)\,x + x_P x_Q$.
This works even if $x_P=x_Q$, for the following reason: in the case of $P=Q$ we chose the line to be a tangent to the curve; therefore, the derivative of \eqref{eq:intersect} is zero at $x_P$; therefore, $x_P$ is a double root of \eqref{eq:intersect} and we can divide it by $x - x_P$ twice.
Performing the polynomial division:
\begin{equation*}\arraycolsep=1pt\def\arraystretch{1.3}
\begin{array}{ll}
& \hspace{60pt} x + A - \lambda^2 + x_P + x_Q \\
x^2 - (x_P + x_Q)\,x + x_P x_Q \;&
\overline{\smash{\big)}\; x^3 + (A - \lambda^2)\, x^2 \hspace{50pt} + (1 - 2\lambda c)\, x \hspace{37pt} - c^2} \\
& \hspace{8pt}\underline{x^3 - (x_P + x_Q)\, x^2 \hspace{40pt} + x_P x_Q x} \\
& \hspace{30pt}(A - \lambda^2 + x_P + x_Q)\, x^2 + (1 - 2\lambda c - x_P x_Q)\, x - c^2 \\
& \hspace{30pt}(A - \lambda^2 + x_P + x_Q)\, x^2 - (A - \lambda^2 + x_P + x_Q)\,(x_P + x_Q)\, x \\
& \hspace{30pt}\underline{\hspace{100pt} +\, (A - \lambda^2 + x_P + x_Q)\,x_P x_Q \hspace{30pt}} \\
& \hspace{130pt}\dots
\end{array}
\end{equation*}
The polynomial division produces an extremely ugly expression as remainder, but fortunately we do not need to compute it, since we know that it must be zero.
From the quotient $x + A - \lambda^2 + x_P + x_Q$ we obtain the $x$ coordinate of the third intersection point $R$:
\begin{equation}
x_R = \lambda^2 - A - x_P - x_Q \label{eq:xR}
\end{equation}
and we obtain the $y$ coordinate by substituting $x_R$ into the line equation~\eqref{eq:line}:
\begin{equation}
y_R = \lambda\,x_R + c = \lambda\,x_R + y_P - \lambda\,x_P = y_P + \lambda\,(x_R - x_P) \label{eq:yR}
\end{equation}
Since $(x_R, y_R)$ is defined whenever $\lambda$ exists, we know that the third intersection point $R$ exists whenever the straight line is not vertical.

\subsection{Constructing a group}\label{sec:group-construction}

An \emph{abelian group} is a set $E$ together with an operation $\bullet$.
The operation combines two elements of the set, denoted $a \bullet b$ for $a, b \in E$.
Moreover, the operation must satisfy the following requirements:
\begin{description}
\item[Closure:] For all $a, b \in E$, the result of the operation $a \bullet b$ is also in $E$.
\item[Commutativity:] For all $a, b \in E$ we have $a \bullet b = b \bullet a$.
\item[Associativity:] For all $a, b, c \in E$ we have $(a \bullet b) \bullet c = a \bullet (b \bullet c)$.
\item[Identity element:] There exists an element $e \in E$, called the \emph{identity element} or \emph{neutral element}, such that for all $a \in E$ we have $e \bullet a = a \bullet e = a$.
\item[Inverse element:] For every $a \in E$ there exists an element $b \in E$ such that $a \bullet b = b \bullet a = e$, where $e$ is the identity element. We then call $b$ the \emph{inverse} of $a$, written $b = a^{-1}$, and vice versa ($a = b^{-1}$).
\end{description}

A group is a very useful abstraction since it has many nice mathematical properties, especially if the number of elements in $E$ is a prime number (this is called a \emph{prime order group}).
Many cryptographic algorithms and protocols use a group without specifying how that group should be implemented.
This works because any two groups with the same prime order are \emph{isomorphic} to each other: informally speaking, they ``behave the same'', regardless of how they are implemented (although their security properties may differ).
The group we are about to define has an infinite number of elements when the $x$ and $y$ coordinates are real numbers, but we will see later how to make it finite.

We will now use the results from the last section to construct a group.
The set of elements is the set of points on the elliptic curve~\eqref{eq:curve}, plus one special element $\infty$ that we call the \emph{point at infinity}:
\begin{equation}
E = \{(x,y) \mid y^2 = x^3 + A x^2 + x\} \;\cup\; \{\infty\}
\end{equation}
The point at infinity has no coordinates, and its purpose is to deal with vertical lines.
When two different points have the same $x$ coordinate and we draw a vertical line through them, like in \autoref{fig:vertical}, we define the point at infinity to be the third point at which the line ``intersects the curve''.
We can imagine this point as lying infinitely far up the $y$ axis, and all vertical lines intersect that point.

The point at infinity will also serve as the identity element of our group.
That is, we define the following to be true:
\begin{equation}
P \bullet \infty \;=\; \infty \bullet P \;=\; P \quad\text{ for all } P \in E. \label{eq:law-identity}
\end{equation}
In particular, $\infty\bullet\infty=\infty$.
Moreover, for any point $P = (x_P, y_P)$ on the curve, we define the \emph{inverse} to be $P^{-1} = (x_P, -y_P)$, i.e.\ the point obtained by mirroring $P$ with respect to the $x$ axis.
By definition, the inverse satisfies the following property:
\begin{equation}
P \bullet P^{-1} \;=\; P^{-1} \bullet P \;=\; \infty \quad\text{ for all } P \in E. \label{eq:law-inverse}
\end{equation}
We also define that $\infty^{-1} = \infty$.

Intuitively, we can think of the operator $P \bullet Q$ as combining two points $P$ and $Q$ by drawing a straight line through them and finding a third point on the curve.
To fully define the operator $\bullet$, we start with the following idea: for any three points $P, Q, R \in E$, if those points lie on the same line, then we have
\begin{equation}
P \bullet Q \bullet R = \infty.
\end{equation}
We can achieve this by defining $P \bullet Q = R^{-1}$, and then $(P \bullet Q) \bullet R = R^{-1} \bullet R = \infty$.
That is, given two curve points $P$ and $Q$, we can draw a straight line through those points, find the third point at which that line intersects the curve, and then invert that point by negating its $y$ coordinate.
The point obtained in this way is $P \bullet Q$.

Using our results~\eqref{eq:xR} and~\eqref{eq:yR} for the coordinates of the third intersection point, along with equations~\eqref{eq:line} and~\eqref{eq:derivative} for the slope $\lambda$, we can now define $P_1 \bullet P_2$ for any two points $P_1$ and $P_2$ on the curve with $P_1 \neq P_2^{-1}$:

\begin{align}
P_1 \bullet P_2 = (x_1, y_1) \bullet (x_2, y_2) &= (x_3, y_3) \quad\text{where}\nonumber\\[10pt]
x_3 = \lambda^2 - A - x_1 - x_2 &= \begin{dcases}
\left(\frac{y_2 - y_1}{x_2 - x_1}\right)^2 - A - x_1 - x_2 & \text{if } x_1 \neq x_2 \\
\left(\frac{3x_1^2 + 2Ax_1 + 1}{2y_1}\right)^2 - A - 2x_1 & \text{if } x_1 = x_2
\end{dcases}\label{eq:law-x}\\[15pt]
y_3 = -(y_1 + \lambda\,(x_3 - x_1)) &= \lambda\,(x_1 - \lambda^2 + A + x_1 + x_2) - y_1 =
\lambda\,(2x_1 + x_2 + A) - \lambda^3 - y_1 =\label{eq:law-y}\\
&= \begin{dcases}
\frac{(2x_1 + x_2 + A) (y_2 - y_1)}{x_2 - x_1} - \left(\frac{y_2 - y_1}{x_2 - x_1}\right)^3 - y_1 & \text{if } x_1 \neq x_2 \\
\frac{(2x_1 + x_2 + A) (3x_1^2 + 2Ax_1 + 1)}{2y_1} - \left(\frac{3x_1^2 + 2Ax_1 + 1}{2y_1}\right)^3 - y_1 & \text{if } x_1 = x_2
\end{dcases}\nonumber
\end{align}

The formulas~\eqref{eq:law-x} and~\eqref{eq:law-y}, along with definitions~\eqref{eq:law-identity} and~\eqref{eq:law-inverse}, form the \emph{group law} for Montgomery curves.
These definitions may seem somewhat arbitrary, but $\bullet$ has to be defined this way in order to obtain a group.
For example, if we did not invert the third intersection point of the line, the resulting operation would not form a group.

To prove that our definitions do indeed form an abelian group, we need to show that the five aforementioned properties hold.
Most of these are easy:
\begin{itemize}
\item The closure property holds by definition, since the point $(x_3, y_3)$ defined by~\eqref{eq:law-x} and~\eqref{eq:law-y} lies on the curve, and the result of the group operation in~\eqref{eq:law-identity} and~\eqref{eq:law-inverse} is also an element of $E$.
\item The identity element $\infty$ exists and has the required behaviour according to definition~\eqref{eq:law-identity}.
\item The inverse element $P^{-1}$ exists for every $P \in E$ and has the required behaviour according to definition~\eqref{eq:law-inverse}.
\item To show that the commutativity property holds, consider several cases.
If $P = \infty$ and/or $Q = \infty$, we have $P \bullet Q = Q \bullet P$ due to~\eqref{eq:law-identity}.
If $P = Q^{-1}$, we have $P \bullet Q = Q \bullet P$ due to~\eqref{eq:law-inverse}.
Finally, if $P \neq \infty$, $Q \neq \infty$ and $P \neq Q^{-1}$, consider the straight line through curve points $P$ and $Q$.
We show that the line through $P$ and $Q$ is the same as the line through $Q$ and $P$, and thus the third intersection point of this line with the curve must be the same.
If $P=Q$, the two lines are trivially the same according to~\eqref{eq:derivative}.
If $P \neq Q$, we examine the line equation~\eqref{eq:line}:
\begin{align}
y = \lambda x + c = \lambda\,(x - x_P) + y_P &= \frac{y_Q - y_P}{x_Q - x_P}\,(x - x_P) + y_P \label{eq:commutative1}\\[5pt]
& = \frac{-(y_P - y_Q)}{-(x_P - x_Q)}\,(x - x_P) + \frac{y_P\,(x_P - x_Q)}{x_P - x_Q} \nonumber\\[5pt]
& = \frac{(y_P - y_Q)\,x - x_P y_P + x_P y_Q + x_P y_P - x_Q y_P}{x_P - x_Q} \nonumber\\[5pt]
& = \frac{(y_P - y_Q)\,x + x_P y_Q - x_Q y_P + (x_Q y_Q - x_Q y_Q)}{x_P - x_Q} \nonumber\\[5pt]
& = \frac{(y_P - y_Q)\,x - (y_P - y_Q)\,x_Q + (x_P - x_Q)\,y_Q}{x_P - x_Q} \nonumber\\[5pt]
& = \frac{y_P - y_Q}{x_Q - x_P}\,(x - x_Q) + y_Q \label{eq:commutative2}
\end{align}
The expressions~\eqref{eq:commutative1} and~\eqref{eq:commutative2} are equal except for swapping $P$ and $Q$.
Thus, we have $P \bullet Q = Q \bullet P$ for all $P, Q \in E$.
\end{itemize}

The final step is to show that $\bullet$ is associative: $(a \bullet b) \bullet c = a \bullet (b \bullet c)$.
Unfortunately, proving associativity is rather more complex than the other properties: proofs of this property involve either some advanced mathematics, or the use of a computer algebra software package~\cite{Friedl:2017js,Fujii:2017eb}.
We will therefore skip the proof of this property.

Instead, to check our result, we can look up Montgomery curves in the \emph{Explicit Formulas Database} (EFD)~\cite{MontgomeryEFD}, which lists the group law as follows:
\begin{verbatim}
name Montgomery curves
parameter a
parameter b
coordinate x
coordinate y
satisfying b y^2 = x^3 + a x^2 + x
addition x = b (y2-y1)^2/(x2-x1)^2-a-x1-x2
addition y = (2 x1+x2+a) (y2-y1)/(x2-x1)-b (y2-y1)^3/(x2-x1)^3-y1
doubling x = b (3 x1^2+2 a x1+1)^2/(2 b y1)^2-a-x1-x1
doubling y = (2 x1+x1+a) (3 x1^2+2 a x1+1)/(2 b y1)-b (3 x1^2+2 a x1+1)^3/(2 b y1)^3-y1
\end{verbatim}
This database uses a slightly more general form $B y^2 = x^3 + A x^2 + x$ with an additional parameter $B$.
We can see that with $B=1$, the formulas in the database equal our formulas~\eqref{eq:law-x} and~\eqref{eq:law-y}.
The formulas in the EFD are checked using the SageMath computer algebra system.

\paragraph{A note on notation.}
In the literature on elliptic curves, the group operation $\bullet$ is traditionally written as $+$, the inverse of $P$ is written as $-P$, combining two different points $P$ and $Q$ using the group operation $P+Q$ is called \emph{point addition}, and combining a point $P$ with itself $P+P=2P$ is known as \emph{point doubling}.
On the other hand, in the literature on cryptographic protocols, the group operation is traditionally written as multiplication $\cdot$, the inverse of $P$ is written as $P^{-1}$, and combining a group element with itself is written as $P \cdot P = P^2$.
In this document we use $\bullet$ as the group operation on \emph{group elements} $E$, in order to avoid confusion with the addition and multiplication of individual \emph{coordinates}, which is used in the formulas above.

\subsection{Elliptic-curve Diffie-Hellman}\label{sec:diffie-hellman}

Now that we have constructed a group, we can use this group for cryptographic protocols.
In particular, Curve25519 is designed for use in \emph{Diffie-Hellman key exchange}, which allows two parties (Alice and Bob) to establish a shared secret by communicating over an insecure channel.
This shared secret can then be used as a key to encrypt and authenticate messages between the two parties.

For a group element $P$ and a non-negative integer $k$ we define the repeated application of the group operator to $P$ as follows:
\begin{equation}
P^k = \underbrace{P \bullet P \bullet \cdots \bullet P}_\text{$k$ times}
\end{equation}
We show in \autoref{sec:ladder} how to compute $P^k$ efficiently, even for large $k$.
This operation is known as \emph{scalar multiplication} (where \emph{scalar} refers to the fact that $k$ is an integer, not a group element).

We can visualise the sequence $P$, $P^2$, $P^3$, {\dots} as repeatedly drawing a line through points $P$ and $P^i$, as shown in \autoref{fig:curve}, finding a third intersection point of this line, and mirroring it with respect to the $x$ axis to obtain point $P^{i+1}$.
The effect, intuitively speaking, is a sequence of points that ``jump around'' the curve in a complicated pattern that is difficult to predict.
This complicated pattern is what makes the group suitable for cryptography.

In particular, if you are given $P$ and $P^k$, it is difficult to determine $k$ (this is known as the \emph{elliptic curve discrete logarithm problem}).
The best known solutions, such as Pollard's rho algorithm~\cite{Pollard:1978do}, boil down to essentially trying lots of values of $k$ until we find a result that matches what we are looking for.
This algorithm takes approximately $O(\sqrt{k})$ time to find $k$.
Thus, if we choose $k$ to be $n$ bits long, the time taken is $O(2^{n/2})$.
Curve25519 chooses $n=251$, making the difficulty of computing the discrete logarithm similar to the difficulty of breaking a 128-bit symmetric cipher.

Let's say that Bob wants anybody to be able to send him encrypted messages, which we can do using Diffie-Hellman.
Bob must first generate a keypair consisting of a private and public key, and make the public key available to anybody.
To generate his keypair, Bob chooses a random integer $j$ as his private key, and computes $P^j$ for a well-known group element $P$.
This point $P$ is called the \emph{base point} or \emph{generator}, and we will see later how it is chosen.
The group element $P^j$ is Bob's public key.

When Alice wants to send an encrypted message to Bob, she obtains Bob's public key $P^j$ and chooses a random integer $k$.
She computes $(P^j)^k$ and uses the result as a key for a symmetric cipher to encrypt her message to Bob.
She also computes $P^k$ and sends this group element to Bob along with her message, while $k$ remains private.
When Bob receives $P^k$ from Alice, he uses his private key $j$ to compute:
\begin{equation*}
(P^k)^j =
\underbrace{(\underbrace{P \bullet\cdots\bullet P}_\text{$k$ times}) \bullet\cdots\bullet (\underbrace{P \bullet\cdots\bullet P}_\text{$k$ times})}_\text{$j$ times} =
\underbrace{P \bullet\cdots\bullet P}_\text{$j \cdot k$ times} =
\underbrace{(\underbrace{P \bullet\cdots\bullet P}_\text{$j$ times}) \bullet\cdots\bullet (\underbrace{P \bullet\cdots\bullet P}_\text{$j$ times})}_\text{$k$ times} =
(P^j)^k
\end{equation*}

\begin{listing}
\begin{minted}[linenos]{c}
typedef unsigned char u8;
typedef unsigned long long u64;
extern void randombytes(u8 *,u64);
static const u8
  _0[16],
  _9[32] = {9};

int crypto_scalarmult_base(u8 *q,const u8 *n)
{ 
  return crypto_scalarmult(q,n,_9);
}

int crypto_box_keypair(u8 *y,u8 *x)
{
  randombytes(x,32);
  return crypto_scalarmult_base(y,x);
}

int crypto_box_beforenm(u8 *k,const u8 *y,const u8 *x)
{
  u8 s[32];
  crypto_scalarmult(s,x,y);
  return crypto_core_hsalsa20(k,_0,s,sigma);
}
\end{minted}
\caption{Using the \texttt{crypto{\PYGZus}scalarmult} function to implement Diffie-Hellman in TweetNaCl}\label{code:diffie-hellman}
\end{listing}

Due to the associativity of $\bullet$, the group element $(P^k)^j$ computed by Bob equals the value $(P^j)^k$ that Alice used to encrypt her message.
Thus, Alice and Bob obtain the same shared secret, and Bob can decrypt Alice's message.
An adversary knows $P$ and $P^j$ (since they are public) and may learn $P^k$ by eavesdropping as it is sent over the network, but will not be able to compute $P^{jk}$ from $P$, $P^j$ and $P^k$ due to the hardness of the discrete logarithm problem.

\autoref{code:diffie-hellman} shows how Diffie-Hellman is implemented in TweetNaCl.
The \verb|crypto_scalarmult(q,n,p)| function takes three arguments: \verb|p| is the input group element $P$, \verb|n| is the scalar exponent, and \verb|q| is a pointer to memory where the output $Q=P^n$ will be written.
\verb|p|, \verb|n| and \verb|q| are all 256-bit numbers, encoded as arrays of 32 bytes.
In fact, \verb|p| and \verb|q| are not full group elements, but only the $x$ coordinate of points on the curve; we will see in \autoref{sec:ladder} why we can leave out the $y$ coordinate.

\verb|crypto_scalarmult_base(q,n)| performs scalar multiplication using a fixed group element \verb|_9|, which is a curve point whose $x$ coordinate equals 9.
We will see later why this particular point was chosen as base point.
The result is again returned in \verb|q|.

\verb|crypto_box_keypair(y,x)| generates a new keypair, where the private key is written to \verb|x| and the public key is written to \verb|y|.
The function generates the private key by simply drawing 32 bytes (256 bits) from a secure source of uniform random numbers.
It then performs scalar multiplication of \verb|x| with the fixed base point in \verb|crypto_scalarmult_base|; the result is the public key.

\verb|crypto_box_beforenm(k,y,x)| is called by both the sender and the recipient of a message.
If called by the sender, \verb|y| is the recipient's public key and \verb|x| is the random integer generated by the sender (Alice's $k$ in the example above).
If called by the recipient, \verb|y| is the group element sent along with the message ($P^k$ in the example above) and \verb|x| is the recipient's private key.
In either case, computing the scalar product of the group element and the secret integer produces the shared secret, which is written to \verb|s|.
The function then initialises the HSalsa20 stream cipher~\cite{Bernstein:2014ca} using this shared secret, and writes the cipher state to \verb|k|.
Subsequent function calls use \verb|k| to encrypt or decrypt the actual message.
We won't discuss this cipher any further in this document, as it is beyond the scope of Curve25519.

\subsection{The Montgomery Ladder}\label{sec:ladder}

The Montgomery ladder~\cite{Bernstein:2017fm,Montgomery:1987fz} is the algorithm used by TweetNaCl to efficiently perform scalar multiplication.
The function $L(P, i)$ takes a group element $P \ne \infty$ and a non-negative integer $i$, and it returns a pair of group elements $(P^i, P^{i+1})$ computed using the group operator $\bullet$:
\begin{align}
L(P,\, 0) &= (\infty, P) \label{eq:ladder}\\
L(P,\, 2i) &= (P_i \bullet P_i,\, P_i \bullet P_{i+1}) & \text{ where } L(P, i) = (P_i, P_{i+1}) \text{ and } i>0 \nonumber\\
L(P,\, 2i+1) &= (P_i \bullet P_{i+1},\, P_{i+1} \bullet P_{i+1}) & \text{ where } L(P, i) = (P_i, P_{i+1}) \text{ and } i \ge 0 \nonumber
\end{align}
Here $P^0 = \infty$ because $\infty$ is the identity element of the group.
The second argument is halved (rounding down, i.e.\ shifting right by one bit) on each recursive call, resulting in $\lfloor\log_2 i\rfloor + 1$ recursive calls to compute $L(P, i)$ (i.e.\ one call per bit of $i$).
In practice, we can use a loop instead of recursion, and in each iteration of the loop we examine one bit of $i$, starting with the most significant bit.
(\autoref{code:scalarmult} on page~\pageref{code:scalarmult} shows the TweetNaCl implementation of the Montgomery ladder; lines~20 to~44 contain the main loop that iterates over the bits of the integer.)
At each loop iteration we perform two group operations:
\begin{itemize}
\item If the bit is zero (i.e.\ the $2i$ case), we combine $P_i$ with itself to produce $P^i \bullet P^i = P^{2i}$, and we combine $P_i$ with $P_{i+1}$ to produce $P^i \bullet P^{i+1} = P^{2i+1}$.
\item If the bit is one (i.e.\ the $2i+1$ case), we combine $P_i$ with $P_{i+1}$ to produce $P^i \bullet P^{i+1} = P^{2i+1}$, and we combine $P_{i+1}$ with itself to produce $P^{i+1} \bullet P^{i+1} = P^{2i+2}$.
\end{itemize}

The reason we return two group elements rather than just one is that, as we shall see shortly, there is a particularly efficient formula for computing $P^i \bullet P^{i+1} = P^{2i+1}$ given $P$, $P^i$ and $P^{i+1}$, which is faster than directly using the group law in~\eqref{eq:law-x}, \eqref{eq:law-y}.

In Curve25519 we need to execute this loop 255 times (the integer in the scalar multiplication function is 256 bits, but we set the topmost bit to always be zero, hence only 255 iterations are needed).
As this is the most time-consuming part of the algorithm, we now examine how to perform these group operations as fast as possible.

\paragraph{Using projective coordinates.}

First of all, notice that equations~\eqref{eq:law-x} and~\eqref{eq:law-y} contain fractions.
If we have to perform division on each iteration of the loop, this division operation would become the slowest part of the algorithm.
To save time, we can represent coordinates as fractions: $x = X/Z$ and $y = Y/Z$, where $X$, $Y$ and $Z$ are integers.
(These are known as \emph{projective coordinates}, whereas the $(x, y)$ coordinates we have been using so far are called \emph{affine coordinates}.)
At each loop iteration we calculate the numerator and denominator for the coordinates separately, without dividing, and we perform the actual division only once, at the end after we have finished the loop.

\paragraph{Projective formulas for point doubling.}

Let's first derive optimised formulas for combining a group element with itself:
$P_{2i} = (x_{2i}, y_{2i}) = P_i \bullet P_i = (x, y) \bullet (x, y)$.
Using the expression in~\eqref{eq:law-x}:
\begin{align}
x_{2i} &= \frac{(3x^2 + 2Ax + 1)^2}{4y^2} - A - 2x \nonumber\\[5pt]
&= \frac{(3x^2 + 2Ax + 1)^2}{4\,(x^3 + Ax^2 + x)} - A - 2x 
    \quad\text{ since } (x, y) \text { is on the curve } y^2 = x^3 + Ax^2 + x \nonumber\\[5pt]
&= \frac{(3x^2 + 2Ax + 1)^2 - 4\,(x^3 + Ax^2 + x)(2x + A)}{4\,(x^3 + Ax^2 + x)} \nonumber\\[5pt]
&= \frac{9x^4 + 12Ax^3 + (4A^2 + 6)\,x^2 + 4Ax + 1 -4\,(2x^4 + 3Ax^3 + (A^2 + 2)\,x^2 + Ax)}{4\,(x^3 + Ax^2 + x)} \nonumber\\[5pt]
&= \frac{x^4 -2x^2 + 1}{4\,(x^3 + Ax^2 + x)} 
    \;=\; \frac{\frac{X^4}{Z^4} - \frac{2X^2}{Z^2} + 1}{4\,\left(\frac{X^3}{Z^3} + \frac{AX^2}{Z^2} + \frac{X}{Z}\right)}
    \quad\text{ using projective coordinates } x=\frac{X}{Z} \label{eq:alt-doubling}\\[5pt]
&= \frac{\frac{1}{Z^4}\,(X^4 - 2X^2 Z^2 + Z^4)}{\frac{4}{Z^3}\,(X^3 + AX^2 Z + X Z^2)}
    \;=\; \frac{X^4 - 2X^2 Z^2 + Z^4}{4XZ\,(X^2 + AX Z + Z^2)}
    \;=\; \frac{(X^2 - Z^2)^2}{4XZ\,(X^2 + AX Z + Z^2)} \nonumber
\end{align}
Thus, we obtain the following projective formulas for point doubling:
\begin{equation}
\left(\frac{X_i}{Z_i}, \frac{Y_i}{Z_i}\right) \bullet \left(\frac{X_i}{Z_i}, \frac{Y_i}{Z_i}\right) =
\left(\frac{X_{2i}}{Z_{2i}}, \frac{Y_{2i}}{Z_{2i}}\right) \quad\text{where}\quad
\begin{array}{l}
    X_{2i} = (X_i^2 - Z_i^2)^2 \\[5pt]
    Z_{2i} = 4X_i Z_i\,(X_i^2 + AX_i Z_i + Z_i^2)
\end{array}\label{eq:projective-double}
\end{equation}

Note that that the formulas for $X_{2i}$ and $Z_{2i}$ do not use the $Y$ coordinate anywhere.
This means that we can avoid computing any $Y$ coordinates in the first place, and we don't even need to derive an expression for $Y_{2i}$.
Next, we will derive formulas for point addition that also avoid using any $Y$ coordinates.

\paragraph{Projective formulas for point addition.}

We now derive optimised formulas for the group operation
$P_{2i+1} = (x_{2i+1}, y_{2i+1}) = P_i \bullet P_{i+1} = (x_1, y_1) \bullet (x_2, y_2)$.
We assume that $P_i \ne P_{i+1}$ (because we know that $P_{i+1} = P^{i+1} = P^i \bullet P = P_i \bullet P$ and we are assuming that $P \ne \infty$), and we also assume that $P_i^{-1} \ne P_{i+1}$ (in this case, $P_{2i+1} = \infty$).
Therefore we can assume $x_1 \neq x_2$.
Taking equation~\eqref{eq:law-x} as our starting point:
\begin{align}
x_{2i+1} &= \left(\frac{y_2 - y_1}{x_2 - x_1}\right)^2 - A - x_1 - x_2 \nonumber\\[5pt]
&= \frac{y_2^2 - 2y_1 y_2 + y_1^2 - (A + x_1 + x_2)\,(x_2 - x_1)^2}{(x_2 - x_1)^2} \nonumber\\[5pt]
&= \frac{x_2^3 + Ax_2^2 + x_2 + x_1^3 + Ax_1^2 + x_1 - 2y_1 y_2}{(x_2 - x_1)^2} \nonumber\\
    &\quad - \frac{Ax_2^2 - 2Ax_1 x_2 + Ax_1^2 + x_1 x_2^2 - 2 x_1^2 x_2 + x_1^3 + x_2^3 - 2x_1 x_2^2 + x_1^2 x_2}{(x_2 - x_1)^2} \nonumber\\[5pt]
&= \frac{x_1 + x_2 + x_1^2 x_2 + x_1 x_2^2 + 2A x_1 x_2 - 2y_1 y_2}{(x_2 - x_1)^2} \nonumber\\[5pt]
&= \frac{(x_1 + x_2)\,(1 + x_1 x_2) + 2A x_1 x_2 - 2y_1 y_2}{(x_2 - x_1)^2} \label{eq:add-x}
\end{align}

Next, we use the fact that $P_{i+1} = P_i \bullet P$.
Because every element of the group has an inverse, we have $P_i^{-1} \bullet P_{i+1} = P_i^{-1} \bullet P_i \bullet P = P$.
Let $P = (x_P, y_P)$, $P_i = (x_1, y_1)$, and $P_{i+1} = (x_2, y_2)$.
Because $P_i^{-1} = (x_1, -y_1)$ we have
\begin{align*}
P = (x_P, y_P) = P_i^{-1} \bullet P_{i+1} = (x_1, -y_1) \bullet (x_2, y_2) \quad\Longrightarrow\quad
x_P = \frac{(x_1 + x_2)\,(1 + x_1 x_2) + 2A x_1 x_2 + 2y_1 y_2}{(x_2 - x_1)^2}
\end{align*}
That is, $x_P$ equals the expression~\eqref{eq:add-x} with $y_1$ inverted.
To clear the remaining occurrences of $y_1$ and $y_2$ from~\eqref{eq:add-x}, without introducing square roots, we multiply $x_{2i+1}$ and $x_P$ (derivation from~\cite{Bernstein:2017fm}):
\begin{align*}
x_P x_{2i+1}\,(x_2 - x_1)^4 &=
    ((x_1 + x_2)\,(1 + x_1 x_2) + 2A x_1 x_2 + 2y_1 y_2)\,((x_1 + x_2)\,(1 + x_1 x_2) + 2A x_1 x_2 - 2y_1 y_2) \\
&= ((x_1 + x_2)\,(1 + x_1 x_2) + 2A x_1 x_2)^2 - (2y_1 y_2)^2 \\
&= ((x_1 + x_2)\,(1 + x_1 x_2) + 2A x_1 x_2)^2 - 4\,(x_1^3 + Ax_1^2 + x_1)\,(x_2^3 + Ax_2^2 + x_2) \\
&= (x_1 + x_2)^2\, (1 + x_1 x_2)^2 + 4Ax_1 x_2\,(x_1 + x_2)\,(1 + x_1 x_2) + 4A^2 x_1^2 x_2^2 \\
    &\quad -4\,(x_1^3 + x_1)\,(x_2^3 + x_2) - 4Ax_1^2\,(x_2^3 + x_2) - 4Ax_2^2\,(x_1^3 + x_1) - 4A^2 x_1^2 x_2^2 \\
&= (x_1 + x_2)^2\, (1 + x_1 x_2)^2 + 4Ax_1 x_2\,(x_1 + x_2 + x_1^2 x_2 + x_1 x_2^2) \\
    &\quad -4\,(x_1^3 + x_1)\,(x_2^3 + x_2) - 4Ax_1 x_2\,(x_1 x_2^2 + x_1 + x_1^2 x_2 + x_2) \\
&= (x_1 + x_2)^2\, (1 + x_1 x_2)^2 - 4\,(x_1^3 + x_1)\,(x_2^3 + x_2) \\
&= (x_1^2 + 2x_1 x_2 + x_2^2)\,(1 + 2x_1 x_2 + x_1^2 x_2^2) - 4\,(x_1^3 x_2^3 + x_1 x_2^3 + x_1^3 x_2 + x_1 x_2) \\
&= x_1^2 + 2x_1 x_2 + x_2^2 + 2x_1^3 x_2 + 4x_1^2 x_2^2 + 2x_1 x_2^3 + x_1^4 x_2^2 + 2x_1^3 x_2^3 + x_1^2 x_2^4 \\
    &\quad - 4x_1^3 x_2^3 - 4x_1 x_2^3 - 4x_1^3 x_2 - 4x_1 x_2 \\
&= x_1^2 - 2x_1 x_2 + x_2^2 - 2x_1^3 x_2 + 4x_1^2 x_2^2 - 2x_1 x_2^3 + x_1^4 x_2^2 - 2x_1^3 x_2^3 + x_1^2 x_2^4 \\
&= (x_2 - x_1)^2 - 2x_1 x_2\,(x_2 - x_1)^2 + x_1^2 x_2^2\,(x_2 - x_1)^2 \\
&= (x_2 - x_1)^2\,(x_1 x_2 - 1)^2
\end{align*}

Hence, under the assumption that $x_P \ne 0$, we obtain
\begin{align}
x_{2i+1} &= \frac{(x_1 x_2 - 1)^2}{x_P\,(x_2 - x_1)^2}
    = \frac{\left(\frac{X_1 X_2}{Z_1 Z_2} - 1\right)^2}{\frac{X_P}{Z_P} \left(\frac{X_2}{Z_2} - \frac{X_1}{Z_1}\right)^2}
    \quad\text{where}\quad x_P = \frac{X_P}{Z_P},\; x_1 = \frac{X_1}{Z_1},\; x_2 = \frac{X_2}{Z_2} \nonumber\\[5pt]
&= \frac{Z_P \left(\frac{X_1^2 X_2^2}{Z_1^2 Z_2^2} - \frac{2X_1 X_2}{Z_1 Z_2} + 1\right)}{X_P \left(\frac{X_2^2}{Z_2^2} - \frac{2X_1 X_2}{Z_1 Z_2} + \frac{X_1^2}{Z_1^2}\right)}
= \frac{\frac{Z_P}{Z_1^2 Z_2^2} \left(X_1^2 X_2^2 - 2X_1 X_2 Z_1 Z_2 + Z_1^2 Z_2^2\right)}{\frac{X_P}{Z_1^2 Z_2^2} \left(X_2^2 Z_1^2 - 2X_1 X_2 Z_1 Z_2 + X_1^2 Z_2^2\right)} \nonumber\\[5pt]
    &= \frac{Z_P\,(X_1 X_2 - Z_1 Z_2)^2}{X_P\,(X_1 Z_2 - X_2 Z_1)^2} \label{eq:projective-add}
\end{align}
In TweetNaCl, the base point $P$ of the scalar multiplication $x_P = X_P/Z_P$ is given as an affine coordinate (i.e.\ not as a fraction), and $P \ne \infty$ so we can assume $Z_P=1$ and $X_P=x_P$.

Thus, we can compute one step of the Montgomery ladder using the formulas from~\eqref{eq:projective-double} and~\eqref{eq:projective-add}:
\begin{align}
X_{2i} &= (X_i^2 - Z_i^2)^2 &
X_{2i+1} &= (X_i X_{i+1} - Z_i Z_{i+1})^2 \label{eq:ladder-step}\\
Z_{2i} &= 4X_i Z_i\,(X_i^2 + AX_i Z_i + Z_i^2) &
Z_{2i+1} &= x_P\,(X_i Z_{i+1} - X_{i+1} Z_i)^2 \nonumber
\end{align}
These formulas never use the $y$ coordinate, allowing us to operate on the $x$ coordinate alone.
They take as input one bit of the scalar, the output from the previous step $(X_i, Z_i, X_{i+1}, Z_{i+1})$, as well as the base point $x$ coordinate $x_P$.
If the current bit is zero, they produce $(X_{2i}, Z_{2i}, X_{2i+1}, Z_{2i+1})$ as output, as shown in~\eqref{eq:ladder}.
If the current bit is one, they produce $(X_{2i+1}, Z_{2i+1}, X_{2i+2}, Z_{2i+2})$ as output, where $X_{2i+2}$ and $Z_{2i+2}$ are computed by applying the doubling formulas to $(X_{i+1}, Z_{i+1})$ instead of $(X_i, Z_i)$.

One desirable property of these formulas is that each step of the ladder performs exactly the same arithmetic operations, regardless of whether the current bit of the scalar is zero or one.
This is important because in Diffie-Hellman's use of scalar multiplication, the scalar is a private key.
We must ensure that the execution time of the algorithm does not depend on the value of the scalar, since such variability in timing could leak the private key through side-channel attacks.
We will see later how exactly this constant-time property is achieved in TweetNaCl.

\subsection{Handling the point at infinity}

In the derivation of the above formulas we have so far considered only points that are solutions to the curve equation, and ignored the point at infinity $\infty$.
It is time that we now address this issue.

The point at infinity cannot be represented in affine coordinates $(x, y)$ for any finite $x$, $y$.
However, a convenient feature of using projective coordinates is that we can represent the point at infinity as a fraction with a denominator of zero: we define the $x$ coordinate of $\infty$ to be $\frac{X}{0}$, i.e.\ $Z = 0$.
We do not allow $X$ and $Z$ to both be zero.
We can ignore the $y$ coordinate since our formulas do not use it.

Fortunately, our formulas~\eqref{eq:ladder-step} already handle the point at infinity correctly.
We demonstrate this by showing that they produce the required result if any of their inputs are $\infty$.
Moreover, we show that provided each input is valid, $(X, Z) \ne (0, 0)$, then the outputs will also be different from $(0, 0)$.
The following assumes that $x_P \ne 0$.

\begin{itemize}
    \item Let $Z_i=0$ and $X_i \ne 0$, so $P_i = \infty$.
        Then $Z_{2i}=0$ and $X_{2i} = X_i^4 \ne 0$, so $P_{2i} = P_i \bullet P_i = \infty\bullet\infty = \infty$ as required by~\eqref{eq:law-identity}.
    \item Let $Z_i \ne 0$. We consider two cases depending on the value of $X_i^3 + AX_i^2 Z_i + X_i Z_i^2$:
        \begin{enumerate}
            \item Assume that $X_i^3 + AX_i^2 Z_i + X_i Z_i^2 = 0$; hence $Z_{2i} = 0$.
                To prove that $X_{2i} \ne 0$, suppose to the contrary that $X_{2i}=0$; then $X_i^2 = Z_i^2$ so $Z_i = \pm X_i$.
                Substituting into $X_i^3 + AX_i^2 Z_i + X_i Z_i^2 = 0$ yields $X_i^3 \pm AX_i^3 + X_i^3 = 0$, so $AX_i^3 = \pm 2X_i^3$.
                Since $Z_i \ne 0$ we have $X_i \ne 0$, and hence $A = \pm 2$.
                However, this contradicts the assumption that $A^2 \ne 4$, stated at the beginning of \autoref{sec:curve-arithmetic}.
                Therefore we have $(X_{2i}, Z_{2i}) \ne (0, 0)$ as required.
            \item Assume that $X_i^3 + AX_i^2 Z_i + X_i Z_i^2 \ne 0$, which implies $X_i \ne 0$.
                Since $Z_i \ne 0$ we have $Z_{2i} \ne 0$, so we have $(X_{2i}, Z_{2i}) \ne (0, 0)$ as required.
        \end{enumerate}
    \item Let $Z_i \ne 0$, $Z_{i+1} \ne 0$, and $P_i$ has the same $x$ coordinate as $P_{i+1}$, i.e.\ $X_i/Z_i = X_{i+1}/Z_{i+1}$.
        This implies one of two situations: either $P_i = P_{i+1}$ or $P_i^{-1} = P_{i+1}$.
        The former is ruled out by our assumption that $P \ne \infty$, so we have $P_i^{-1} = P_{i+1}$ and require that $P_i \bullet P_{i+1} = \infty$ as per~\eqref{eq:law-inverse}.
        $X_i/Z_i = X_{i+1}/Z_{i+1}$ implies that $X_i Z_{i+1} = X_{i+1} Z_{i}$, so $Z_{2i+1} = 0$ as required.

        Next, we need to show that $X_{2i+1} \ne 0$.
        Suppose to the contrary that $X_{2i+1} = 0$, implying that $X_i X_{i+1} - Z_i Z_{i+1} = 0$.
        Taken together with the fact $X_i Z_{i+1} = X_{i+1} Z_{i}$ that we showed earlier, we have $X_i X_{i+1} - Z_i Z_{i+1} - X_i Z_{i+1} + X_{i+1} Z_{i} = (X_i + Z_i)\,(X_{i+1} - Z_{i+1}) = 0$.
        We now have two cases:
        \begin{enumerate}
            \item If $X_i + Z_i = 0$ then $X_i = -Z_i$ so $X_i/Z_i = -1$.
                Using assumption $X_i/Z_i = X_{i+1}/Z_{i+1}$ we have $X_{i+1}/Z_{i+1} = x_{i+1} = -1$, so the affine $x$ coordinate of $P_{i+1}$ equals $-1$.
            \item If $X_i + Z_i \ne 0$ then $X_{i+1} = Z_{i+1}$ so $X_{i+1}/Z_{i+1} = x_{i+1} = 1$, so the affine $x$ coordinate of $P_{i+1}$ equals $1$.
        \end{enumerate}
        In both cases, we use the point doubling expression~\eqref{eq:alt-doubling} to calculate the $x$ coordinate of $P_{i+1} \bullet P_{i+1}$, which is $(x_{i+1}^4 -2x_{i+1}^2 + 1)/(4x_{i+1}^3 + 4Ax_{i+1}^2 + 4x_{i+1}) = 0$ for $x_{i+1} = \pm 1$.
        Note that $P_{i+1} = P_i \bullet P$, so $P = P_i^{-1} \bullet P_{i+1} = P_{i+1} \bullet P_{i+1}$ due to our earlier observation that $P_i^{-1} = P_{i+1}$.
        Hence, the $x$ coordinate of $P$ equals zero, which contradicts our earlier assumption that $x_P \ne 0$.
        Thus we have $X_{2i+1} \ne 0$ as required.
    \item Let $Z_i \ne 0$, $Z_{i+1} \ne 0$, and $P_i$ has a different $x$ coordinate from $P_{i+1}$, i.e.\ $X_i/Z_i \ne X_{i+1}/Z_{i+1}$.
        Then $X_i Z_{i+1} \ne X_{i+1} Z_i$ so $Z_{2i+1} \ne 0$, so $P_{2i+1} \ne \infty$ as required.
    \item Let $Z_i=0$ and $X_i \ne 0$, so $P_i = \infty$.
        Since $P_{i+1} = P_i \bullet P = \infty \bullet P = P$ and $P \ne \infty$ we have $Z_{i+1} \ne 0$ and $X_{i+1}/Z_{i+1} = x_P$, so $X_{i+1} = x_P Z_{i+1}$.
        Hence, $X_{2i+1} = (X_i X_{i+1})^2 = x_P^2 X_i^2 Z_{i+1}^2$ and $Z_{2i+1} = x_P\,(X_i Z_{i+1})^2 \ne 0$.
        Thus, $X_{2i+1}/Z_{2i+1} = x_P^2 X_i^2 Z_{i+1}^2 / x_P X_i^2 Z_{i+1}^2 = x_P$ so $P_{2i+1} = P_i \bullet P_{i+1} = \infty \bullet P = P$ as required by~\eqref{eq:law-identity}.
    \item Let $Z_{i+1} = 0$ and $X_{i+1} \ne 0$, so $P_{i+1} = \infty$.
        Since $P_{i+1} = P_i \bullet P$ and $P \ne \infty$ we have $P_i = P^{-1}$ and $Z_i \ne 0$.
        The $x$ coordinate of $P^{-1}$ is the same as the $x$ coordinate of $P$, namely $x_P$, so $X_i/Z_i = x_P$, so $X_i = x_P Z_i$.
        Hence, similarly to the last case, we have $X_{2i+1} = (X_i X_{i+1})^2 = x_P^2 X_{i+1}^2 Z_i^2$ and $Z_{2i+1} = x_P\,(-X_{i+1} Z_i)^2 \ne 0$.
        Thus, $X_{2i+1}/Z_{2i+1} = x_P^2 X_{i+1}^2 Z_i^2 / x_P X_{i+1}^2 Z_i^2 = x_P$, which is consistent with $P_{2i+1} = P_i \bullet P_{i+1} = P^{-1} \bullet \infty = P^{-1}$ as required by~\eqref{eq:law-identity}.
\end{itemize}

These bullet points cover all possible cases, demonstrating that the formulas~\eqref{eq:ladder-step} correctly handle all group elements, including the point at infinity, without need for any special handling of edge cases.
That is good news because the lack of edge cases simplifies the implementation of the Montgomery ladder.
Moreover, it is easier to make the algorithm constant-time if every step of the ladder performs exactly the same arithmetic operations, independently of the values of its inputs.

\subsection{Optimising the Montgomery ladder step}\label{sec:ladder-optimised}

The formulas~\eqref{eq:ladder-step} are nice and simple, but if we compare them to the TweetNaCl implementation of the Montgomery ladder in \autoref{code:scalarmult}, the two look quite different.
The reason is that the code is based on formulas that have been further optimised.

We have already avoided using division in the Montgomery ladder step by moving to projective coordinates.
To further improve the performance, we will aim to reduce the number of multiplications as far as possible, since they are generally the most expensive operations after division.
We ignore additions and subtractions since they are cheap by comparison.

If we break down the formulas~\eqref{eq:ladder-step} into one multiplication per equation, reusing common sub-expressions where possible, we see that each step of the ladder requires 14 multiplications:
\begin{align*}
    v_1 &= X_i^2    & v_5    &= A v_3                   & v_6 &= X_i X_{i+1}    & v_{10}   &= (v_8 - v_9)^2 \\
    v_2 &= Z_i^2    & X_{2i} &= (v_1 - v_2)^2           & v_7 &= Z_i Z_{i+1}    & X_{2i+1} &= (v_6 - v_7)^2 \\
    v_3 &= X_i Z_i  & Z_{2i} &= v_4\,(v_1 + v_5 + v_2)  & v_8 &= X_i Z_{i+1}    & Z_{2i+1} &= x_P v_{10}    \\
    v_4 &= 4 v_3    &        &                          & v_9 &= X_{i+1} Z_i
\end{align*}
Some authors count multiplication by a constant ($4$ or $A$, in the case of $v_4$ and $v_5$) and squaring separately from multiplication.
However, TweetNaCl uses the same multiplication function in all cases, so for simplicity we count all types of multiplication equally.

\begin{listing}
\begin{minted}[linenos]{c}
#define FOR(i,n) for (i = 0;i < n;++i)
typedef long long i64;
typedef i64 gf[16];
static const gf _121665 = {0xDB41,1},

int crypto_scalarmult(u8 *q,const u8 *n,const u8 *p)
{
  u8 z[32];
  i64 x[80],r,i;
  gf a,b,c,d,e,f;
  FOR(i,31) z[i]=n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  FOR(i,16) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for(i=254;i>=0;--i) {
    r=(z[i>>3]>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  FOR(i,16) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  inv25519(x+32,x+32);
  M(x+16,x+16,x+32);
  pack25519(q,x+16);
  return 0;
}
\end{minted}
\caption{The Montgomery ladder for scalar multiplication in TweetNaCl}\label{code:scalarmult}
\end{listing}

In contrast to the above 14 multiplications, TweetNaCl uses only 10 multiplications per step.
In this section we focus on how to derive the algorithm in \autoref{code:scalarmult} from the formulas~\eqref{eq:ladder-step}.
The main ladder loop in lines~20 to~44 of \autoref{code:scalarmult} performs the following operations:
\begin{itemize}
    \item \verb|r=(z[i>>3]>>(i&7))&1| sets \verb|r| to be the \verb|i|th bit from the little-endian byte array \verb|z| (which was previously set to be a copy of the parameter \verb|n|, with a few tweaks explained later).
    \item \verb|sel25519(a,b,r)| examines the bit \verb|r|, which is either 0 or 1.
        If \verb|r == 0|, the function does nothing.
        If \verb|r == 1|, the function swaps the values in the two variables \verb|a| and \verb|b|.
        It does this in constant time, so the ``do nothing'' case takes the same execution time as the swapping case.
    \item \verb|A(x,y,z)| computes \verb|y| plus \verb|z|, and writes the sum to \verb|x|.
    \item \verb|Z(x,y,z)| computes \verb|y| minus \verb|z|, and writes the difference to \verb|x|.
    \item \verb|M(x,y,z)| multiplies \verb|y| and \verb|z|, and writes the product to \verb|x|.
    \item \verb|S(x,y)| squares the value in \verb|y|, and writes the result to \verb|x|.
        \verb|S(x,y)| is the same as \verb|M(x,y,y)|.
\end{itemize}
We will discuss the implementation of these functions in \autoref{sec:field-arithmetic}.

Each iteration of the loop takes as input the values in variables \verb|a|, \verb|b|, \verb|c|, \verb|d|, \verb|x|, and \verb|z|, as well as the constant \verb|_121665 = {0xDB41,1}|, which contains the number \verb|0x1DB41| = 121665 (split into 16-bit chunks as explained in \autoref{sec:field-arithmetic}).
As output it writes new values to the variables \verb|a|, \verb|b|, \verb|c|, and \verb|d|.
Moreover, it uses \verb|e| and \verb|f| as temporary variables.
In the code of \autoref{code:scalarmult}, variables are reused.
For better readability, we give a new name to each variable assignment in the following breakdown of the operations.
The 18 arithmetic operations in the Montgomery ladder loop (10 multiplications/squarings and 8 additions/subtractions) compute the following expressions:
\begin{align*}
    & \texttt{A(e,a,c);} & v_1    &= a + c \\
    & \texttt{Z(a,a,c);} & v_2    &= a - c \\
    & \texttt{A(c,b,d);} & v_3    &= b + d \\
    & \texttt{Z(b,b,d);} & v_4    &= b - d \\
    & \texttt{S(d,e);}   & v_5    &= v_1^2          &&= (a + c)^2 \\
    & \texttt{S(f,a);}   & v_6    &= v_2^2          &&= (a - c)^2 \\
    & \texttt{M(a,c,a);} & v_7    &= v_3 \cdot v_2  &&= (b + d)\,(a - c) = ab - bc + ad - cd \\
    & \texttt{M(c,b,e);} & v_8    &= v_4 \cdot v_1  &&= (b - d)\,(a + c) = ab + bc - ad - cd \\
    & \texttt{A(e,a,c);} & v_9    &= v_7 + v_8      &&= 2\,(ab - cd) \\
    & \texttt{Z(a,a,c);} & v_{10} &= v_7 - v_8      &&= 2\,(ad - bc) \\
    & \texttt{S(b,a);}   & v_{11} &= v_{10}^2       &&= 4\,(ad - bc)^2 \\
    & \texttt{Z(c,d,f);} & v_{12} &= v_5 - v_6      &&= (a + c)^2 - (a - c)^2 = a^2 + 2ac + c^2 - a^2 + 2ac - c^2 = 4ac \\
    & \texttt{M(a,c,{\char`_}121665);} & v_{13} &= 121665 \cdot v_{12} &&= 486660\, ac = (A - 2)\,ac \\
    & \texttt{A(a,a,d);} & v_{14} &= v_{13} + v_5   &&= (A - 2)\,ac + a^2 + 2ac + c^2 = a^2 + Aac + c^2 \\
    & \texttt{M(c,c,a);} & v_{15} &= v_{12} \cdot v_{14} &&= 4ac\, (a^2 + Aac + c^2) \\
    & \texttt{M(a,d,f);} & v_{16} &= v_5 \cdot v_6  &&= (a + c)^2\,(a - c)^2 = (a^2 + 2ac + c^2)\,(a^2 - 2ac + c^2) \\
    &                    &        &                 &&= a^4 + 2a^3 c + a^2 c^2 - 2a^3 c - 4 a^2 c^2 - 2a c^3 + a^2 c^2 + 2a c^3 + c^4 \\
    &                    &        &                 &&= a^4 - 2a^2 c^2 + c^4 = (a^2 - c^2)^2 \\
    & \texttt{M(d,b,x);} & v_{17} &= v_{11} \cdot x &&= 4x\,(ad - bc)^2 \\
    & \texttt{S(b,e);}   & v_{18} &= v_9^2          &&= 4\,(ab - cd)^2
\end{align*}

Let $a = X_i$, $b = X_{i+1}$, $c = Z_i$, $d = Z_{i+1}$, and $x = x_P$ at the start of a loop iteration.
Further let the bit \verb|r| be 0, so the \verb|sel25519| operations have no effect.
Then the expressions above match the equations \eqref{eq:ladder-step} with $A = 486662$, $v_{16} = X_{2i}$, $v_{18} = 4X_{2i+1}$, $v_{15} = Z_{2i}$, and $v_{17} = 4Z_{2i+1}$.
The values $(v_{16}, v_{18}, v_{15}, v_{17})$ are written to variables \verb|a|, \verb|b|, \verb|c|, and \verb|d| respectively, forming the input to the next iteration.

If the bit \verb|r| is 1, the values in \verb|a| and \verb|b| are swapped before and after the computation of these expressions, and likewise the values in \verb|c| and \verb|d| are swapped.
Thus, the inputs to the computation are $a = X_{i+1}$, $b = X_i$, $c = Z_{i+1}$, and $d = Z_i$, and the outputs are $v_{16} = X_{2i+2}$, $v_{18} = 4X_{2i+1}$, $v_{15} = Z_{2i+2}$, and $v_{17} = 4Z_{2i+1}$.
After the final swaps, the variables \verb|a|, \verb|b|, \verb|c|, and \verb|d| contain the values $(v_{18}, v_{16}, v_{17}, v_{15})$.

Thus, each loop iteration maps input $(X_i, Z_i, X_{i+1}, Z_{i+1})$ to either output $(X_{2i}, Z_{2i}, 4X_{2i+1}, 4Z_{2i+1})$ or output $(4X_{2i+1}, 4Z_{2i+1}, X_{2i+2}, Z_{2i+2})$ depending on the value of \verb|r|.
This exactly matches the Montgomery ladder step~\eqref{eq:ladder}, except for the additional factor of 4 in $X_{2i+1}$ and $Z_{2i+1}$.
However, since these two variables are just an expanded representation of the fraction $x_{2i+1} = X_{2i+1}/Z_{2i+1}$, these two factors of 4 cancel out and have no effect on the final result.

%TODO \url{https://en.wikipedia.org/wiki/Montgomery_curve} has some detail on formulas for group arithmetic

\section{Finite field arithmetic}\label{sec:field-arithmetic}

Some parts of the derivation in \autoref{sec:curve-arithmetic}, such as the use of the derivative to compute the slope of the tangent to the curve at a particular point, assumed that the elliptic curve coordinates $(x, y)$ are real numbers.
However, for cryptographic purposes it is much more useful if the coordinates are integers within a finite range (i.e.\ integers that can be represented in a fixed number of bits).

Fortunately, the group law for Montgomery curves~\eqref{eq:law-x} and \eqref{eq:law-y}, and the subsequent derivation of the Montgomery ladder, are valid not just for real numbers, but for any \emph{field}.
Building upon the definition of an abelian group in \autoref{sec:group-construction}, a field is a set of elements $F$ along with two operators (multiplication $a \cdot b$ and addition $a + b$), with the following properties:
\begin{itemize}
    \item The set $F$ and the addition operator $+$ form an abelian group with identity element $0$.
        We denote the inverse of $a \in F$ in this group as $-a$.
        The subtraction operator $a - b$ is then shorthand for $a + (-b)$.
    \item The set $F \setminus \{0\}$ and the multiplication operator $\cdot$ form an abelian group with identity element $1$.
        We denote the inverse of $a \in F$ in this group as $a^{-1}$.
        The division operator $a/b$ is then shorthand for $a \cdot (b^{-1})$.
    \item The addition and multiplication operators satisfy the distributive law: $a \cdot (b + c) = (a \cdot b) + (a \cdot c)$.
\end{itemize}
The real numbers $\mathbb{R}$ along with the usual addition and multiplication operators form a field with an infinite set of elements, but we can also define a field where the set of elements $F$ is finite.
This is called a \emph{finite field}, also known as \emph{Galois field}.

Curve25519 uses the finite field of integers modulo $p = 2^{255}-19$ (hence the name).
This field consists of the set of integers $\mathbb{Z}_p = \{0, 1, \dots, p-1\}$, where addition and multiplication are performed modulo $p$: that is, any number $\ge p$ is \emph{reduced modulo $p$} by subtracting multiples of $p$ until the number is within the range $[0,\, p-1]$.
If two numbers $a$ and $b$ reduce to the same integer modulo $p$, we say that they are \emph{congruent modulo $p$}, written $a \equiv b \pmod{p}$.
More formally, we have $a \equiv b \pmod{p}$ if and only if there exists $k \in \mathbb{Z}$ such that $a - b = kp$.

The additive inverse of $a$ modulo $p$ is $-a = p - a$, which always exists.
Moreover, because $p$ is a prime number, every number $a \in \{1, \dots, p-1\}$ has a multiplicative inverse $a^{-1}$ modulo $p$: that is, for every $a \not\equiv 0$ there exists $b \in \{1, \dots, p-1\}$ such that $a \cdot b = 1$.
Note that when we perform division modulo $p$, e.g.\ calculating $a/b = a \cdot (b^{-1})$, the result is still an integer modulo $p$, not a fraction.

\subsection{Arithmetic operators in TweetNaCl}

Since Curve25519 coordinates are integers modulo $2^{255}-19$, we can represent them as 255-bit numbers.
TweetNaCl uses two different representations for these numbers: either as a 32-element array of 8-bit pieces (bytes), or as a 16-element array of 16-bit pieces.
The 32-byte representation is used for input and output, while the representation using 16-bit pieces is used internally by the arithmetic operators.

In the TweetNaCl code, the \verb|gf| datatype (short for Galois field?) is used for the latter representation.
Even though each piece is just 16 bits, it is declared as a 16-element array of 64-bit signed integers, for reasons that will become clear shortly.
\autoref{code:unpack25519} shows the \verb|unpack25519| function, which converts a number from the byte array representation to the \verb|gf| representation.
In the last line, it forces the most significant bit (the 256th bit) to be zero; this makes sense because our numbers are always less than $2^{255}$.

\begin{listing}
\begin{minted}{c}
#define FOR(i,n) for (i = 0;i < n;++i)
#define sv static void
typedef unsigned char u8;
typedef i64 gf[16];

sv unpack25519(gf o, const u8 *n)
{
  int i;
  FOR(i,16) o[i]=n[2*i]+((i64)n[2*i+1]<<8);
  o[15]&=0x7fff;
}
\end{minted}
\caption{Converting an integer modulo $p$ from the byte array representation to the array of 16-bit pieces.}\label{code:unpack25519}
\end{listing}

\begin{listing}
\begin{minted}{c}
sv sel25519(gf p,gf q,int b)
{
  i64 t,i,c=~(b-1);
  FOR(i,16) {
    t= c&(p[i]^q[i]);
    p[i]^=t;
    q[i]^=t;
  }
}
\end{minted}
\caption{Conditionally swapping the values in two variables.}\label{code:sel25519}
\end{listing}

\autoref{code:sel25519} shows the definition of the \verb|sel25519(p,q,b)| function, which swaps the content of \verb|p| and \verb|q| if the bit \verb|b| is 1, and does nothing if \verb|b| is 0, as discussed in \autoref{sec:ladder-optimised}.
This function also operates on the \verb|gf| representation of integers.
It first sets \verb|c=~(b-1)|, which equals 0 if \verb|b == 0|, and \verb|0xffff...| if \verb|b == 1|.
Next it iterates over each of the 16 pieces of the number, and computes \verb|t = c&(p[i]^q[i])| for index \verb|i|, which equals 0 if \verb|b == 0|, and \verb|p[i]^q[i]| if \verb|b == 1|.
The operation \verb|p[i] ^= t| thus has no effect if \verb|b == 0|, and sets \verb|p[i] = p[i] ^ (p[i] ^ q[i]) = q[i]| if \verb|b == 1|.
Likewise, \verb|q[i]| is set to \verb|p[i]| if \verb|b == 1|.
This function performs exactly the same operations regardless of the value of \verb|b|, so it is constant-time.

% Montgomery curves and their arithmetic https://eprint.iacr.org/2017/212.pdf

% Discussion of clamping https://twitter.com/Sc00bzT/status/1270331532490747904

% Other things to look at: NIST P-256 curve; Ed25519; secp256k1 ECDSA (bitcoin); petlib https://petlib.readthedocs.io/en/latest/
% Ristretto255 https://ietf.org/id/draft-irtf-cfrg-ristretto255-00.html

\bibliographystyle{plainurl}
\bibliography{references}

\end{document}
